{"config":{"lang":["en"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Misc Notes","text":"<p>Repository to store notes I made for courses I took which didn't have a cheat sheet system, so they are not organized by evaluation topics, but by the order in which it was taught.</p>"},{"location":"cg/","title":"Computer Graphics","text":"<p>Notes I make while taking the course of Computer Graphics. The course is taught by Prof. Ojaswa Sharma.</p>"},{"location":"cg/colors/","title":"Colors","text":""},{"location":"cg/colors/#measuring-light","title":"Measuring Light","text":"<ul> <li>Colorimetry is the science of measuring light and color.</li> <li>Sensations that arise from light energy of different wavelengths</li> <li>Color is a phenomenon of human perception and not a universal property of light</li> <li>The photodetectors in human retina consists of rods and cones<ul> <li>Rods : Sensitive to brightness</li> <li>Cones : Sensitive to color </li> </ul> </li> </ul>"},{"location":"cg/colors/#cone-responses","title":"Cone Responses","text":"<ul> <li>Three types of cones in human retina<ul> <li>S-cones : Sensitive to short wavelengths</li> <li>M-cones : Sensitive to medium wavelengths</li> <li>L-cones : Sensitive to long wavelengths</li> </ul> </li> <li>Response of a cone is magnitude of electrical signal generated in response to light of a particular wavelength. \\(\\phi(\\lambda)\\) is the wavelength density function of the incident light, and \\(L(\\lambda)\\), \\(M(\\lambda)\\), and \\(S(\\lambda)\\) are the response functions of the L, M, and S cones, respectively. The response of the cones can be expressed as:</li> </ul> \\[ L = \\int_{\\lambda} \\phi(\\lambda) L(\\lambda) d\\lambda \\] \\[ M = \\int_{\\lambda} \\phi(\\lambda) M(\\lambda) d\\lambda \\] \\[ S = \\int_{\\lambda} \\phi(\\lambda) S(\\lambda) d\\lambda \\]"},{"location":"cg/colors/#colorometric-concepts","title":"Colorometric Concepts","text":"<ul> <li>Luminance : Brightness of a color</li> <li>Chromaticity : Color without brightness</li> <li>Dominant Wavelegth : Single spectral color (hue)</li> <li>Purity : Ratio of pure color to white light (saturation)</li> </ul>"},{"location":"cg/colors/#color-matching","title":"Color matching","text":"<p>Photoreceptors act as linear intergrators of light energy. This means it's possible to find two different spectral distributions \\(-\\phi_1(\\lambda)\\) and  \\(-\\phi_2(\\lambda)\\) that produce the same response in the cones. This is the basis of color matching. This is called metamerism. </p> <ul> <li>Spectral tri-stimulus values - using monochromatic light sources to match a given color</li> <li>CIE defined three primaries: 435.8 nm(B), 546.1 nm(G) and 700.0 nm(R)</li> <li>A color can be matched by a linear combination of the three primaries</li> <li>Negative values means that wavelength is too saturated to be produced by the primary</li> </ul> <p>It's possible to transform one set of tristimulus values to another</p> <ul> <li>CIE defined a standard observer with color matching functions \\(X(\\lambda)\\), \\(Y(\\lambda)\\), and \\(Z(\\lambda)\\)</li> <li>Cannot be realized physically</li> </ul>"},{"location":"cg/colors/#color-spaces","title":"Color spaces","text":"<ul> <li>We could define an orthogonal coordinate system with \\(X\\), \\(Y\\), and \\(Z\\) as the axes</li> <li>Color gamut: spacial extent of volume in which colors lie</li> </ul> \\[ x = \\frac{X}{X+Y+Z} \\hspace{1cm} y = \\frac{Y}{X+Y+Z} \\hspace{1cm} z = \\frac{Z}{X+Y+Z} \\] \\[ X = \\frac{x}{y} Y \\hspace{1cm} Z = \\frac{1-x-y}{y} Y \\] <p>We usually represent Z in terms of X and Y, and Y is the luminance.</p>"},{"location":"cg/colors/#chromaticity-diagram","title":"Chromaticity Diagram","text":"Chromaticity Diagram <ul> <li>All colors visible to the human eye lie within the horseshoe shaped curve</li> <li>The straight line connecting two points on the curve represents all the colors that can be produced by mixing the two colors</li> <li>The edge of the diagram, called the specral locus, represents pure mono-chromatic colors. These are the most saturated colors</li> <li>The least saturated colors are at the center of the diagram, where the white point is located</li> <li>Color gamut: subet of colors that can be produced by a particular device</li> </ul>"},{"location":"cg/colors/#other-color-spaces","title":"Other color spaces","text":"Space Description Cons RGB Additive color model, Based on human perception of color Not perceptually uniform, High correlation between components HSV Hue, Saturation, Value Hue discontinuity at 0 and 360 degrees, Bad correlation between computed and perceived lightness CMYK Subtractive color model, used in printing"},{"location":"cg/curves/","title":"Curves","text":"<p>Path of a continuously moving point in the space. Set of all points where the moving point has been.</p>"},{"location":"cg/curves/#mathematical-description","title":"Mathematical Description","text":"<ul> <li>Parametric Curves:<ul> <li>In 2D: \\(C(t) = (x(t), y(t)), C: \\mathbb{R} \\rightarrow \\mathbb{R^2}\\)</li> <li>In 3D: \\(C(t) = (x(t), y(t), z(t)), C: \\mathbb{R} \\rightarrow \\mathbb{R^3}\\)</li> </ul> </li> <li>Implicit Curves: Defined as the set of points satisfying an equation \\(f(x, y) = 0\\).<ul> <li>In 2D: \\(C = \\{(x, y): f(x, y) = 0 \\}\\)</li> <li>In 3D: \\(C = \\{(x, y, z): f(x, y, z) = 0 \\}\\)</li> </ul> </li> </ul> <p>Warning</p> <p>Always ensure that Implicit curves are of the form \\(f(x, y) = 0\\) and not \\(f(x, y) = c\\).</p>"},{"location":"cg/curves/#some-representations-of-popular-curves","title":"Some representations of popular curves","text":"Curve Parametric Implicit Line \\(p(t) = p_0 + (p_1 - p_0)t, t \\in (-\\infty, \\infty)\\) \\(C = \\{(x, y): ax + by + c = 0\\}\\) Circle \\(p(t) = (r\\cos(t), r\\sin(t)), t \\in [0, 2\\pi]\\) \\(C = \\{(x, y): x^2 + y^2 - r^2 = 0\\}\\) <p>Note</p> <p>Always mention the range of the parameter \\(t\\) when defining a parametric curve.</p> <p>Parametric Polynomial Curves: \\(C(t) = \\{x(t), y(t)\\}\\) is polynomial iff \\(x(t)\\) and \\(y(t)\\) are polynomials in \\(t\\).</p>"},{"location":"cg/curves/#approximation-curves","title":"Approximation Curves","text":"<p>Do not need to interpolate all the points(i.e. pass through all the points). Approximation curves are used to represent the shape of the curve.</p> <p>Examples:</p> <ul> <li>Bezier Curves</li> <li>B-Spline Curves</li> <li>Catmull-Rom Splines</li> <li>etc.</li> </ul>"},{"location":"cg/curves/#bezier-curves","title":"Bezier Curves","text":"Quadratic Bezier Curve <p>Bezier curves are defined by a set of control points. Nth order Bezier curve is defined by N+1 control points. Equation of Linear Bezier curve is given by:</p> \\[B^1(t) = (1-t)P_0 + tP_1\\] <p>where \\(P_0\\) and \\(P_1\\) are the control points. Bezier curves are defined recursively. The general equation for Nth order Bezier curve is given by:</p> \\[B^n(t) = (1-t)B^{n-1}(t) + tB^{n-1}(t)\\] <p>or they can be defined using all the control points as:</p> \\[B^n(t) = \\sum_{i=0}^{n} {n \\choose i} (1-t)^{n-1}t^i P_i\\] <p>where \\({n \\choose i}\\) is the binomial coefficient, and \\(P_i\\) are the control points.</p>"},{"location":"cg/curves/#properties-of-bezier-curves","title":"Properties of Bezier Curves","text":"<ul> <li>The curve always passes through the end points, i.e. \\(B^n(0) = P_0\\) and \\(B^n(1) = P_n\\).</li> <li>The curve is a straight line iff all the control points are collinear.</li> <li> <p>The start and end tangent vectors are parallel to the line joining the first and last control points, i.e.</p> \\[\\frac{dB}{dt}|_{t = 0} \\propto \\overrightarrow{P_0 P_1} \\hspace{40px} \\text{ and } \\hspace{40px} \\frac{dB}{dt}|_{t = 1} \\propto \\overrightarrow{P_{n-1} P_n}\\] </li> <li> <p>Convex Hull Property: The curve lies within the convex hull of the control points.</p> </li> </ul> Convex Hull (the boundary is P0 P1 P2 P3) <p>Note</p> <p>Convex Hull is the smallest convex set that contains all the control points. Convex set is a set where the line segment joining any two points in the set lies entirely within the set.</p> <ul> <li>Each \\(n\\)th order Bezier curve has an equally shaped \\(n+1\\)th order Bezier curve</li> <li>Is Affine Invariant: The curve remains the same under affine transformations (i.e. translation, rotation, scaling, and shear).</li> </ul> Rational Bezier Curves <p>Rational Bezier curves are defined by dividing each control point by a weight. The equation for Rational Bezier curve is given by:</p> \\[B^n(t) = \\frac{\\sum_{i=0}^{n} {n \\choose i} (1-t)^{n-1}t^i w_i P_i}{\\sum_{i=0}^{n} {n \\choose i} (1-t)^{n-1}t^i w_i}\\] <p>where \\(w_i\\) are the weights. They have better local control and can represent conic sections, but they are computationally expensive.</p>"},{"location":"cg/curves/#interpolation-curves","title":"Interpolation Curves","text":"<p>Given a set of points \\(P_0, P_1, \\dots, P_n\\) , we want to construct a curve that passes through all the points. \\(C(k) = p_k\\) where \\(k = 0, 1, \\dots, n-1\\).</p> <p>Some interpolation curves are:</p> <ul> <li>Lagrange Interpolation</li> <li>Piecewise Bezier Curves</li> <li>Piecewise B-Spline Curves</li> <li>etc.</li> </ul> <p> </p> Different types of interpolation"},{"location":"cg/curves/#lagrange-interpolation","title":"Lagrange Interpolation","text":"<p>Given a set of points \\(P_0, P_1, \\dots, P_n\\), the Lagrange interpolation polynomial is given by:</p> \\[L(k) = \\sum_{i=0}^{n} P_i l_i(k)\\] <p>where \\(l_i(k)\\) are the Lagrange basis functions given by:</p> \\[l_i(k) = \\prod_{j=0, j \\neq i}^{n} \\frac{k - k_j}{k_i - k_j}\\] <p>We rarely use Lagrange interpolation in practice because of the huge oscillations and large interpolation error.</p>"},{"location":"cg/curves/#piecewise-interpolation-curves","title":"Piecewise Interpolation Curves","text":"<p>Known as \"Poly-Curves\". Each segment  between two interpolation points is represented by a curve. </p> <p> </p> Two types of interpolation, Linear on the right and Cubic Bezier on the left"},{"location":"cg/curves/#continuity-in-piecewise-curves","title":"Continuity in Piecewise Curves","text":"<p>Parametric Continuity \\(C^n\\)</p> <ul> <li>Segments have equal \\(n\\)th derivative at the junction points.</li> <li>Tangents have equal direction and magnitude at the junction points.</li> </ul> Continuity Description \\(C^-1\\) Curve is discontinuous \\(C^0\\) Curve is continuous \\(C^1\\) First Derivative is continuous \\(C^2\\) Second Derivative is continuous \\(C^n\\) \\(n\\)th Derivative is continuous <p>Geometric Continuity \\(G^n\\): Tangents have equal direction but not magnitude at the junction points. Curve is \\(G^n\\) continuous if it can be reparametrized to be \\(C^n\\) continuous.</p> Continuity Description \\(G^0\\) Curve touch at the joint point (=\\(C^0\\)) \\(G^1\\) Curves share a common tangent direction \\(G^2\\) Curves share a common center of curvature"},{"location":"cg/lighting/","title":"Lighting and Shading","text":"<ul> <li>A surface can emit light (self-emission) or reflect light from other sources.</li> <li>Recursive scattering of light between surfaces accounts for subtle shading effects. This can be expressed in the rendering equation.</li> <li>The rendering equation can either be physically based or empirical.</li> <li>Physically based rendering is very time consuming and expensive to compute, but it produces realistic images.</li> </ul> Lighting"},{"location":"cg/lighting/#surface-types-based-on-light-matter-interaction","title":"Surface types based on light-matter interaction","text":"<ul> <li>Specular surfaces: Shiny surfaces that reflect light in a narrow range of directions close to the angle of reflection.</li> <li>Glossy surfaces: Surfaces that are shiny but not as shiny as specular surfaces.</li> <li>Diffuse surfaces: Rough surfaces that reflect light in all directions.</li> <li>Translucent surfaces: Surfaces that allow light to pass through them.</li> </ul> Surface Types"},{"location":"cg/lighting/#physically-based-rendering-aka-global-illumination","title":"Physically Based Rendering a.k.a Global Illumination","text":""},{"location":"cg/lighting/#some-terms","title":"Some Terms","text":"<ul> <li>Flux (\\(\\Phi(A)\\)): The amount of light energy passing through a surface per unit time. Unit is watts.</li> <li>Irradiance (\\(E(A)\\)): Flux per unit area arriving at a surface. Unit is watts per square meter. \\(\\(E(A) = \\frac{d\\Phi(A)}{dA(x)}\\)\\)</li> <li>Radioisity (\\(B(A)\\)): The total amount of light energy leaving a surface per unit time. Unit is watts.</li> </ul> <ul> <li>Radiance (\\(L(\\mathbf{x}, \\vec{\\omega})\\)): Flux density per unit solid angle, per perpendicular unit area</li> </ul> \\[L(\\mathbf{x}, \\vec{\\omega}) = \\frac{d^2\\Phi(A)}{d\\vec{\\omega}dA^\\perp (x, \\vec{\\omega})}\\] <ul> <li>Solid Angle (\\(\\Omega\\)): The angle subtended by a surface at a point in space. Unit is steradian.</li> </ul> \\[\\Omega = \\frac{A}{r^2}\\]"},{"location":"cg/lighting/#bidirectional-reflectance-distribution-function-brdf","title":"Bidirectional Reflectance Distribution Function (BRDF)","text":"<ul> <li>Ratio between outgoing radiance for angle \\(\\omega_o\\) and incoming irradiance for angle \\(\\omega_i\\).</li> <li>BRDF describes Density w.r.t \\(\\omega_i\\). Integrating it over all incoming irradiance gives the total outgoing radiance.</li> </ul> \\[\\rho(\\omega_i, \\omega_o) = \\frac{d}{d \\omega_i} \\frac{L_o(\\omega_o)}{L_i(\\omega_i) \\cos{\\theta_i}}\\] BRDF BRDF for different surfaces"},{"location":"cg/lighting/#properties-of-brdf","title":"Properties of BRDF","text":"<ul> <li>Positivity: \\(\\rho(\\omega_i, \\omega_o) \\geq 0\\)</li> <li>Reciprocity: \\(\\rho(\\omega_i, \\omega_o) = \\rho(\\omega_o, \\omega_i)\\)</li> <li>Energy Conservation: </li> </ul> \\[\\forall \\omega_i: \\int_{\\Omega} \\rho(\\omega_i, \\omega_o) d\\omega_o \\leq 1\\]"},{"location":"cg/lighting/#the-rendering-equation","title":"The rendering equation","text":"\\[L_o(\\mathbf{x}, \\vec{\\omega_o}) = E_o(\\mathbf{x}, \\vec{\\omega_o}) + \\int_{\\Omega} \\rho(\\mathbf{x}, \\vec{\\omega_i}, \\vec{\\omega_o}) L_i(\\mathbf{x}, \\vec{\\omega_i}) \\cos{\\theta_i} d\\omega_i\\] <p>This is too complicated to understand, so we will reduce it to a simpler form.</p> <ul> <li>Unknown function \\(L\\) is related to linear operator (integration) on itself + emission function \\(E\\).</li> <li>Discrete<ul> <li>Functions \\(\\rightarrow\\) Vectors, Linear operators \\(\\rightarrow\\) Matrices</li> <li>\\(L = E + K \\cdot L\\)</li> <li>Linear system of equations</li> </ul> </li> <li>Rendering becomes solving a linear system of equations. </li> </ul> \\[ \\begin{align*} L &amp;= E + K \\cdot L \\\\ L &amp;= (I - K)^{-1} \\cdot E \\\\ &amp;= \\sum_{i=0}^{\\infty} K^i \\cdot E \\end{align*} \\] <p>The last line is formed by the Neumann series expansion of \\((I - K)^{-1}\\).</p>"},{"location":"cg/lighting/#light-paths","title":"Light Paths","text":"<ul> <li>Heckbert's notation for light paths:</li> <li>Expresses light paths in terms of surface interactions</li> <li>\\(L\\) - Light source</li> <li>\\(E\\) - Eye</li> <li>\\(S\\) - Specular reflection/refraction</li> <li>\\(D\\) - Diffused reflection</li> </ul> <p>We can represent light paths as a regular expression</p> <ul> <li><code>*</code> - Zero or more occurrences</li> <li><code>+</code> - One or more occurrences</li> <li><code>?</code> - Zero or one occurrence</li> <li><code>|</code> - OR</li> </ul> <p>Heckbert's classification of light paths:</p> <ul> <li>Direct illumination: \\(L(D|S)E\\)</li> <li>Indirect illumination: \\(L(D|S)D(D|S)+E\\)</li> <li>Classical (Whitted) ray tracing: \\(LDS*E\\)</li> <li>Full global illumination: \\(L(D|S)*E\\)</li> </ul>"},{"location":"cg/lighting/#approximate-models","title":"Approximate models","text":""},{"location":"cg/lighting/#phong-reflection-model","title":"Phong Reflection Model","text":"<ul> <li>Blinn-Phong reflection model is a simplified model that approximates the shading of a surface.</li> <li>Efficient to compute and provides good results.</li> <li>Consists of three components: ambient, diffuse, and specular reflection.</li> </ul> \\[I = I_a + I_d + I_s\\] Phong Model"},{"location":"cg/lighting/#ambient-reflection","title":"Ambient Reflection","text":"<ul> <li>Any point whose normal is not facing the light source will appear black.</li> <li>In reality, light bounces off other surfaces and illuminates the point.</li> <li>An ambient term is added to account for this.</li> </ul> \\[I_a = k_a \\cdot I_{a}, \\text{ where } 0 \\leq k_a \\leq 1 \\]"},{"location":"cg/lighting/#diffuse-reflection","title":"Diffuse Reflection","text":"<ul> <li>Lambertian objects reflect light equally in all directions.</li> <li>No change in color with respect to the angle of view.</li> <li>Lambert's cosine law: intensity is proportional to the cosine of the angle between the light source and the normal. If \\(l\\) is the light vector (pointing towards the light source) and \\(n\\) is the normal vector, then the intensity \\(c\\) is given by:</li> </ul> \\[c \\propto n \\cdot l\\] <ul> <li>Reflection coefficient \\(k_d\\) represents fraction of light reflected.</li> </ul> \\[I_d = k_d L_d \\max((l \\cdot n), 0)\\]"},{"location":"cg/lighting/#light-source-attenuation","title":"Light source Attenuation","text":"<ul> <li>Energy decreases as the inverse square with distance </li> <li>Therefore for diffuse lighting, </li> </ul> \\[I_d = k_d f_{att} L_d \\max((l \\cdot n), 0)\\] <p>where \\(f_{att}\\) is the light source attenuation function </p> <ul> <li>A common attenuation function is</li> </ul> \\[f_{att} = \\min\\left(\\frac{1}{a + bd + cd^2}, 1\\right)\\] <p>where \\(d\\) is the distance between the light source and the point, and \\(a\\), \\(b\\), and \\(c\\) are constants.</p>"},{"location":"cg/lighting/#specular-reflection","title":"Specular Reflection","text":"<ul> <li>Phong lighting model adds a specular reflection term to the lighting equation.</li> <li>The amount of light that the viewer sees depends on the angle \\(\\phi\\) between \\(r\\) (reflected direction) and \\(v\\) (view vector).</li> </ul> \\[I_s = k_s L_s \\max((r \\cdot v)^n, 0)\\] <p>where \\(n\\) is the shininess coefficient.</p> <p>Reflected Vector</p> <p>Two fundamental conditions - Angle of incidence = Angle of reflection - At a point \\(p\\) on the surface, the incident light vector \\(l\\) and the reflected light vector \\(r\\) are coplanar with the normal vector \\(n\\) at \\(p\\).</p> <p> </p> <ul> <li>\\(\\theta_i = \\theta_r \\implies \\cos{\\theta_i} = \\cos{\\theta_r} \\implies l \\cdot n = r \\cdot n\\)</li> <li>\\(r = \\alpha n + \\beta l\\) </li> <li>\\(n \\cdot r = n \\cdot (\\alpha n + \\beta l) = \\alpha n \\cdot n + \\beta n \\cdot l = \\beta n \\cdot l = l \\cdot n\\)</li> <li>\\(l = r \\cdot r = \\alpha^2 + 2 \\alpha \\beta l \\cdot n + \\beta^2 = 1\\)</li> <li>\\(r = 2(n \\cdot l)n - l\\)</li> </ul>"},{"location":"cg/lighting/#putting-it-all-together","title":"Putting it all together","text":"\\[I = \\frac{1}{a + bd + cd^2} (k_d L_d \\max((l \\cdot n), 0) + k_s L_s \\max((r \\cdot v)^n, 0)) + k_a I_a\\] <p>The diffuse and are computed and added for each light source.</p> <p>If there are multiple light sources, then separate diffuse and specular terms are computed for each light source and added together.</p> \\[I = k_a I_a + \\sum_{i=1}^{n} (f_{att} (k_{d_i} L_{d_i} \\max(l_i \\cdot n, 0)) + k_{s_i} L_{s_i} \\max((r_i \\cdot v)^n, 0))\\]"},{"location":"cg/lighting/#modified-phong-model","title":"Modified Phong Model","text":"<ul> <li>With Phong model, the reflected vector \\(r\\) needs to be computed at every point on surface </li> <li>To avoid this expensive computation, halfway vector \\(h\\) is used.</li> </ul> \\[h = \\frac{l + v}{||l + v||}\\] <ul> <li>Replace \\(r \\cdot v\\) with \\(h \\cdot n\\) with \\(n \\cdot h\\).</li> <li>Phong highlights will be smaller than before</li> </ul> Modified Phong Model"},{"location":"cg/lighting/#transparent-surfaces","title":"Transparent Surfaces","text":"<ul> <li>Both specular and diffuse transmissions can take place at the surfaces of a transparent surface. </li> <li>When a beam of light is incident on a transparent material, part of it is reflected and part of it is refracted.</li> </ul> <p>Snell's Law</p> <ul> <li>The angle of incidence and the angle of refraction are related by Snell'js Law.</li> <li>\\(\\eta_i \\sin{\\theta_i} = \\eta_r \\sin{\\theta_r}\\)</li> <li>\\(\\eta_i\\) and \\(\\eta_r\\) are the refractive indices of the incident and refracted media respectively.</li> <li>\\(\\theta_i\\) and \\(\\theta_r\\) are the angles of incidence and refraction respectively.  </li> </ul> Refraction <ul> <li>Refraction occurs whenever light passes from one medium to another with a different refractive index.</li> <li>Law of refraction: Incident ray \\(d\\), refracted ray \\(t\\) and normal \\(n\\) are coplanar.</li> </ul> <p>Let \\(n\\) and \\(b\\) be basis vectors of the plane containing \\(d\\) and \\(t\\).</p> <ul> <li>\\(t = \\sin{\\theta_r} b - \\cos{\\theta_r} n\\)</li> <li>\\(d = \\sin{\\theta_i} b - \\cos{\\theta_i} n \\implies b = \\frac{d + n \\cos{\\theta_i}}{\\sin{\\theta_i}}\\)</li> </ul> \\[ \\begin{align*} t &amp;= \\frac{\\eta_i}{\\eta_r} (d + n\\cos{\\theta_i}) - n \\cos{\\theta_r}\\\\ &amp;= \\frac{\\eta_i}{\\eta_r} (d - n(d \\cdot n)) - n \\sqrt{1 - \\left(\\frac{\\eta_i}{\\eta_r}\\right)^2 (1 - (d \\cdot n)^2)}\\\\ \\end{align*} \\]"},{"location":"cg/lighting/#fresnel-equations","title":"Fresnel Equations","text":"<ul> <li>Reflectivity of a dielectric surface varies with the angle of incidence according to the Fresnel equations.</li> <li>Schlick's approximation is a common way to approximate the Fresnel equations.</li> </ul> \\[ R(\\theta) = R_0 + (1 - R_0)(1 - \\cos{\\theta})^5\\] <p>where \\(R_0\\) is the reflectance at normal incidence, and \\(\\theta\\) is the angle of incidence.</p> \\[R_0 = \\left(\\frac{\\eta_r - 1}{\\eta_r + 1}\\right)^2\\] <p>Thus,</p> \\[I = (1 - R(\\theta)) I_{trans} + R(\\theta) T_{refl}\\]"},{"location":"cg/lighting/#polygon-rendering-methods","title":"Polygon Rendering Methods","text":""},{"location":"cg/lighting/#flat-shading","title":"Flat Shading","text":"<ul> <li>All points within a face of the model are assigned the same color.</li> <li>All vertices of the face have same normal.</li> <li>Gives a faceted look to the model.</li> </ul>"},{"location":"cg/lighting/#gouraud-shading","title":"Gouraud Shading","text":"<ul> <li>Also known as intensity interpolation.</li> <li>Linearly interpolates vertex intensities across the face.</li> <li>All vertices of the face have different normals.</li> </ul>"},{"location":"cg/lighting/#phong-shading","title":"Phong Shading","text":"<ul> <li>Also known as normal vector interpolation.</li> <li>Interpolates normal vectors across the face instead of intensities.</li> <li>All points within a face have different normals.</li> </ul>"},{"location":"cg/mesh/","title":"Mesh","text":""},{"location":"cg/mesh/#introduction-to-mesh-and-its-properties","title":"Introduction to Mesh and it's properties","text":"<p>Piecewise linear approximation with error \\(O(h^2)\\) is called a mesh</p> <p>Mesh elements</p> <ul> <li>Face: Subset of a 3d plane</li> <li>Edge: Incident points of 2 or more faces</li> <li>Vertex: Incident points of 2 or more edges</li> </ul> <p>Mesh Local Structure</p> <ul> <li>Element type: Triangle, Quad meshes, or polygon meshes. We always use triangles as they are always planar.</li> <li>Element shape: Isotropic, i.e. locally uniform in all directions, or anisotropic, i.e. non-uniform in all directions.</li> <li>Element density: Uniform or non-uniform. Non-uniform density is used to refine the mesh in regions of interest.</li> </ul> <p>Note</p> <p>For better illustrations, see lecture slides on google classroom. I might add some illustrations here in the future myself but for now, I will just leave it as it is.</p> <p>Regularity of Mesh</p> <ul> <li>Irregular: any number of irregular vertices</li> <li>Semi-regular: small number of irregular vertices</li> <li>Highly regular: most vertices are regular</li> <li>Regular: all vertices are regular</li> </ul> <p>Info</p> <p>A Vertex is regular if it is incident to 6 edges. We generally use regular meshes as they are easier to work with.</p>"},{"location":"cg/mesh/#mesh-data-structures","title":"Mesh Data Structures","text":""},{"location":"cg/mesh/#face-set","title":"Face Set","text":"<p>It is simply a list of faces. Each face is represented by a list of vertices.</p> Faces \\(f_1 = (v_{11}, v_{12}, v_{13})\\) \\(f_2 = (v_{21}, v_{22}, v_{23})\\) \\(\\vdots\\) \\(f_n = (v_{n1}, v_{n2}, v_{n3})\\) Face Vertex \\(v_1 = (x_1, y_1, z_1)\\) Vertex \\(v_2 = (x_2, y_2, z_2)\\) Vertex \\(v_3 = (x_3, y_3, z_3)\\) Face Set"},{"location":"cg/mesh/#indexed-face-set","title":"Indexed Face Set","text":"<p>This time we are using indices to represent the vertices. This is useful when we have a large number of vertices and faces. This reduces redundancy and makes the data structure more compact.</p> Face VertexRef \\(v_1, v_2, v_3\\) FaceRef \\(f_1, f_2, f_3\\) FaceData data Vertex Point \\((x, y, z)\\) FaceRef data VertexData data Vertices \\(v_1 =  (x_1, y_1, z_1)\\) \\(v_2 =  (x_2, y_2, z_2)\\) \\(\\vdots\\) \\(v_n =  (x_n, y_n, z_n)\\) Faces \\(f_1 = (i_{11}, i_{12}, i_{13})\\) \\(f_2 = (i_{21}, i_{22}, i_{23})\\) \\(\\vdots\\) \\(f_n = (i_{n1}, i_{n2}, i_{n3})\\) Indexed Face Set"},{"location":"cg/mesh/#winged-edge","title":"Winged Edge","text":"<p>This is a more complex data structure. Each Vertex and Face have a reference to an edge along with some other data. Each edge has the following</p> <ul> <li>Vertex references (\\(v_0\\) being the source and \\(v_1\\) being the target)</li> <li>Face references (\\(f_L\\) and \\(f_R\\))</li> <li>Previous and Next edge references for the left and right face</li> <li>Edge data</li> </ul> <p>Warning</p> <p>Edges in a face always follow anti-clockwise order.</p> Vertex Point position EdgeRef edge VertexData data Face EdgeRef edge FaceData data Edge VertexRef \\(v_0\\) \\(v_1\\) FaceRef \\(f_L\\) \\(f_R\\) EdgeRef \\(e_{{prevL}}\\) \\(e_{{prevR}}\\) EdgeRef \\(e_{{nextL}}\\) \\(e_{{nextR}}\\) EdgeData data Winged Edge"},{"location":"cg/mesh/#one-ring-traversal-in-winged-edge","title":"One Ring Traversal in Winged Edge","text":"<ul> <li>Start with a vertex</li> <li>Get one of its edges</li> <li>Add the other vertex of the edge to the one ring</li> <li>Set <code>curr_edge = ePrevL</code></li> <li>Till <code>curr_edge-&gt;v0</code> is not equal to the first vertex in ring, add it</li> <li>Repeat for <code>ePrevR</code></li> </ul> One Ring Traversal in Winged Edge"},{"location":"cg/mesh/#half-edge","title":"Half Edge","text":"<p>Half edge is a more compact data structure. Each edge is split into two half edges. Each half edge has the following</p> <ul> <li>Vertex reference</li> <li>Face reference (always the one in anti-clockwise direction)</li> <li>Next half edge reference</li> <li>Previous half edge reference</li> <li>Twin half edge reference</li> <li>Half edge data</li> </ul> Vertex Point position HalfEdgeRef edge VertexData data Face HalfEdgeRef edge FaceData data Edge VertexRef vertex FaceRef face HalfEdgeRef prev HalfEdgeRef next HalfEdgeRef twin EdgeData data Half Edge"},{"location":"cg/mesh/#one-ring-traversal-in-half-edge","title":"One Ring Traversal in Half Edge","text":"<ul> <li>Start with a vertex</li> <li>Go to one of its half edges</li> <li>Switch to reverse edge (twin)</li> <li>Go to the next half edge (original vertex)</li> <li>Repeat until you repeat the original edge</li> </ul> One Ring Traversal in Half Edge"},{"location":"cg/mesh/#boundary-traversal-in-half-edge","title":"Boundary Traversal in Half Edge","text":"<ul> <li>Start with a boundary edges</li> <li>Go to the next boundary edge</li> <li>Switch to the reverse edge (twin)</li> <li>Repeat until you reach the original edge</li> </ul> Boundary Traversal in Half Edge Directed Edge <p>Half edge modification for triangular meshes.</p> <ul> <li>Store all 3 half-edges of common face next to each other in memory.</li> <li>Let \\(f\\) be the index of the same face. Place it's \\(k\\)th \\((0,1,2)\\) half-edge at index \\(3f+k\\) in the array.</li> <li>Then \\(h\\)th half-edge belongs to \\(f\\)th face = \\(h / 3\\)</li> <li>Index of \\(h\\)th half-edge in the array = \\(h mod 3\\)</li> <li>No need to store face-to-edge and face-to-edge references.</li> </ul>"},{"location":"cg/mesh/#performance-comparison-of-mesh-data-structures","title":"Performance Comparison of Mesh Data Structures","text":"One Ring, Two Ring, and k-Ring <ul> <li>One Ring: All vertices connected to a vertex by an edge. </li> <li>Two Ring: Vertex connected to a vertex in the one ring. </li> <li>k-Ring: All vertices connected to a vertex by an edge or a vertex connected to a vertex in the k-1 ring.</li> </ul> <p>Roughly speaking, the one ring is the immediate neighbors of a vertex, the two ring is the neighbors of the neighbors, and so on.</p> Data Structure Space per Vertex Mesh Topology Rendering One-Ring Traversal Boundary Traversal Face Set 72 bytes Static, fixed (3,4) Fast Slow Slow Indexed Face Set 36 bytes Static, fixed (3,4) Fast Slow Slow Winged Edge 120 bytes Any (2 manifolds) Medium Slow (case distinctions) Slow Half Edge 144 / 96 bytes Any (2 manifolds) Medium / Slow Fast Fast Directed Edge 64 bytes Regular Triangular / Quad Meshes (2 manifolds) Medium/Slow Medium Medium"},{"location":"cg/mesh/#pros-and-cons-of-mesh-data-structures","title":"Pros and Cons of Mesh Data Structures","text":"Data Structure Pros Cons Face Set Static meshes; rendering No explicit connectivity information; data redundancy Indexed Face Set Simple and efficient storage; Static meshes; rendering No explicit connectivity information; Not efficient for most algorithms Winged Edge Arbitrary Polygonal Meshes Massive cse distinctions for one-ring traversal Half Edge One-ring traversal; explicit representation of edges Slow rendering"},{"location":"cg/mesh/#applications-of-mesh-data-structures","title":"Applications of Mesh Data Structures","text":"Data Structure Applications Face Set Stereolithography (3D printing) Indexed Face Set Rendering Winged Edge Rarely used Half Edge Mesh refinement, decimation, smoothing"},{"location":"cg/ray_tracing/","title":"Ray Tracing","text":"<p>Rendering is a process that takes as inputs a set of objects and produces an array of pixels. It can be organized in 2 ways</p> <ul> <li>Object-order rendering: Where the objects are processed one by one</li> <li>Image-order rendering: Where the pixels are processed one by one</li> </ul> <p>Ray tracing is an image-order algorithm</p>"},{"location":"cg/ray_tracing/#basic-algorithm","title":"Basic Algorithm","text":"<p>A basic ray tracer consists of three parts </p> <ul> <li>Ray generation : Computes origin and direction of each pixel's viewing ray based on camera geometry</li> <li>Ray intersection : Finds the intersection of the viewing ray with the scene geometry</li> <li>Lighting : Computes the color of the pixel based on the result of ray-object intersection</li> </ul> <pre><code>for each pixel in the image:\n    compute viewing ray\n    find first object hit by the ray and its surface normal n\n    shade the pixel using hit-point, light and n\n</code></pre>"},{"location":"cg/ray_tracing/#ray-generation-or-computing-viewing-ray","title":"Ray Generation or Computing Viewing Ray","text":"<ul> <li>basic tools for ray generation are the viewpoint and the image plane</li> <li>Ray representation \\(p(t) = e + t (s - e)\\), where \\(e\\) is eye and \\(s\\) is a point on the image plane</li> <li>Point \\(e\\) is ray's origin and (s - e) is ray's direction</li> </ul> Ray Generation <ul> <li>Ray generation takes place from the camera frame</li> <li>position \\(e\\) (eye point)</li> <li>\\(\\mathbf{u},  \\mathbf{v},  \\mathbf{w}\\) are basis vectors</li> <li>Choose \\(-w\\) as view direction and an up vector, using which we construct the basis vectors</li> </ul> Camera Vectors"},{"location":"cg/ray_tracing/#orthographic-views","title":"Orthographic Views","text":"<ul> <li>All rays will have direction \\(- \\mathbf{w}\\)</li> <li>A viewpoint is not require but viewing rays can start from the plane containing the camera, so we know when object is behind the camera.</li> <li>Viewing rays start on the image plane and are parallel to each other, and cab be defined by point \\(e\\) and vectors \\(\\mathbf{u}\\) and \\(\\mathbf{v}\\)</li> </ul> Orthographic Rays <ul> <li>\\(l\\) and \\(r\\) are left and right limits of the image plane (measured along $\\mathbf{u} $) \\(l &lt; 0 &lt; r\\)</li> <li>\\(b\\) and \\(t\\) are bottom and top limits of the image plane (measured along \\(\\mathbf{v}\\)) \\(b &lt; 0 &lt; t\\)</li> </ul> <p>Pixel spacing for \\(n_x \\times n_y\\) image is</p> <ul> <li>Horizontal : \\(\\Large \\frac{r - l}{n_x}\\)</li> <li>Vertical : \\(\\Large \\frac{t - b}{n_y}\\)</li> </ul> <p>Therefore, pixel position \\((i, j)\\) in the raster image is </p> <ul> <li>\\(u = l + \\Large \\frac{(r - l)(i + 0.5)}{n_x}\\)</li> <li>\\(v = b + \\Large \\frac{(t - b)(j + 0.5)}{n_y}\\)</li> </ul> <p>Where \\(u, v\\) are the coordinates of the pixel in the image plane w.r.t origin \\(e\\) and basis vectors \\(\\mathbf{u} ,  \\mathbf{v}\\)</p> <p>Therefore, Ray parameters are </p> <ul> <li>Origin: \\(e + u * \\mathbf{u} + v * \\mathbf{v}\\)</li> <li>Direction : \\(-\\mathbf{w}\\)</li> </ul>"},{"location":"cg/ray_tracing/#perspective-views","title":"Perspective Views","text":"<ul> <li>All rays will have different directions for different pixels</li> <li>All rays will have origin at the eye point</li> </ul> Perspective Rays <ul> <li>Image plane positioned at distance \\(d\\) from the eye point \\(e\\)</li> <li>Ray parameters are <ul> <li>Origin: \\(e\\)</li> <li>Direction: \\(-d * \\mathbf{w} + u * \\mathbf{u} + v * \\mathbf{v}\\)</li> </ul> </li> </ul> <p>Where \\(u, v\\) are the coordinates of the pixel in the image plane w.r.t origin \\(e\\) and basis vectors \\(\\mathbf{u} ,  \\mathbf{v}\\) </p> <p>Note</p> <p>In some sense, the origin in orthographic view is direction in perspective view.</p>"},{"location":"cg/ray_tracing/#ray-intersection","title":"Ray intersection","text":"<ul> <li>Given a generated ray \\(p(t) = e + t \\cdot d\\), find intersection (first hit) with the scene geometry such that \\(t &gt; 0\\)</li> <li>Given a ray \\(p(t) = e + t \\cdot d\\), and an implcit surface \\(f(p) = 0\\), the intersection point is found by solving \\(f(e + t \\cdot d) = 0\\) </li> <li>There can be multiple solutions for \\(t\\), but we are interested in the smallest positive solution</li> </ul>"},{"location":"cg/ray_tracing/#for-sphere","title":"For Sphere","text":"<ul> <li>Parametric equation for any point \\(p\\) on a sphere with center \\(c\\) and radius \\(r\\) is </li> </ul> \\[ (p - c) \\cdot (p - c) - r^2 = 0 \\] <ul> <li>For finding points of intersection of a ray with a sphere, we substitute \\(p = e + t \\cdot d\\) in the above equation and solve for \\(t\\)</li> </ul> \\[ \\begin{align*}     (e + t \\cdot d - c) \\cdot (e + t \\cdot d - c) - r^2 &amp;= 0 \\\\     (d \\cdot d) t^2 + 2 (d \\cdot (e - c)) t + (e - c) \\cdot (e - c) - r^2 &amp;= 0 \\end{align*} \\] <p>This gives the solution</p> \\[t = \\frac {-(d \\cdot (e - c)) \\pm \\sqrt{(d \\cdot (e - c))^2 - (d \\cdot d) ((e - c) \\cdot (e - c) - r^2)}}{d \\cdot d}\\]"},{"location":"cg/ray_tracing/#normal-for-sphere","title":"Normal for Sphere","text":"<ul> <li>The normal vector at \\(\\mathbf{p}\\) on the implicit surface \\(f(p)\\) is given by </li> </ul> \\[n = \\nabla f(p) = (\\frac{\\partial f(p)}{\\partial x}, \\frac{\\partial f(p)}{\\partial y}, \\frac{\\partial f(p)}{\\partial z})\\] <ul> <li>For sphere, the normal at point \\(p\\) is</li> </ul> \\[n = 2(p - c) \\hspace{20px} \\text{and} \\hspace{20px} \\hat{n} = \\frac{p - c}{R}\\]"},{"location":"cg/ray_tracing/#for-triangle","title":"For Triangle","text":"<ul> <li>Parametric equation for a triangle is</li> </ul> \\[\\mathbf{e} + t \\mathbf{d} = \\mathbf{f}(u, v)\\] <ul> <li> <p>3 unknowns \\(t, u, v\\) and 3 equations \\((x, y, z)\\) for the triangle. We can solve for \\(t, u, v\\) and check if \\(u, v\\) are within the range of the triangle.</p> </li> <li> <p>For a parametric plane, the parametric surface can be represented in terms of any three points in the plane. Utilize barycentric coordinates for ray-triangle test </p> </li> <li> <p>For a triangle with vertices \\(\\mathbf{a},  \\mathbf{b}, \\mathbf{c}\\) intersection will occur when </p> </li> </ul> \\[\\mathbf{e} + \\mathbf{d} t = \\mathbf{a} + \\beta (\\mathbf{b} - \\mathbf{a}) + \\gamma (\\mathbf{c} - \\mathbf{a})\\] <ul> <li>Intersection is inside the triangle if \\(\\beta, \\gamma \\geq 0\\) and \\(\\beta + \\gamma \\leq 1\\)</li> <li>To solve for \\(t, \\beta, \\gamma\\), we can write the above equation as</li> </ul> \\[ \\begin{align*}     x_e + t x_d &amp;= x_a + \\beta (x_b - x_a) + \\gamma (x_c - x_a) \\\\     y_e + t y_d &amp;= y_a + \\beta (y_b - y_a) + \\gamma (y_c - y_a) \\\\     z_e + t z_d &amp;= z_a + \\beta (z_b - z_a) + \\gamma (z_c - z_a) \\end{align*} \\] <p>This can be written in matrix form as</p> \\[ \\begin{bmatrix}     x_a - x_b &amp; x_a - x_c &amp; x_d \\\\     y_a - y_b &amp; y_a - y_c &amp; y_d \\\\     z_a - z_b &amp; z_a - z_c &amp; z_d \\end{bmatrix} \\begin{bmatrix}     \\beta \\\\     \\gamma \\\\     t \\end{bmatrix} =  \\begin{bmatrix}     x_a - x_e \\\\     y_a - y_e \\\\     z_a - z_e \\end{bmatrix} \\] <ul> <li> <p>Let \\(A\\) be the matrix on the left, \\(B\\) be the matrix on the right, then using Cramer's rule, we can solve for \\(\\beta, \\gamma, t\\) as follows</p> </li> <li> <p>Let \\(A_i\\) be the matrix obtained by replacing \\(i^{th}\\) column of \\(A\\) with the column of \\(B\\), then values of \\(\\beta, \\gamma, t\\) are</p> </li> </ul> \\[ \\beta = \\frac{\\text{det}(A_1)}{\\text{det}(A)} \\hspace{20px} \\gamma = \\frac{\\text{det}(A_2)}{\\text{det}(A)} \\hspace{20px} t = \\frac{\\text{det}(A_3)}{\\text{det}(A)} \\]"},{"location":"cg/ray_tracing/#ray-polygon-intersection","title":"Ray-Polygon Intersection","text":"<p>Givem \\(m\\) vertices \\(p_1, p_2, \\ldots, p_m\\) of a polygon and surface normal \\(n\\) - Compute the intersection point between ray \\(\\mathbf{e} + t \\mathbf{d}\\) and the plane containing the polygon \\((p - p_1) \\cdot n = 0\\)</p> \\[t = \\frac{(p_1 - e) \\cdot n}{d \\cdot n}\\] <ul> <li>If \\(\\mathbf{p}\\) is inside the polygon, then the ray hits it.</li> </ul>"},{"location":"cg/ray_tracing/#point-in-polygon-test","title":"Point-in-Polygon Test","text":""},{"location":"cg/ray_tracing/#ray-polygon-intersection-or-crossing-number-algorithm","title":"Ray Polygon Intersection or Crossing Number Algorithm","text":"<ul> <li>Send a 2D ray out from \\(p\\) and count the number of intersections between the ray and the polygon</li> <li>If the intersection count is odd, then \\(p\\) is inside the polygon</li> </ul> <p>Warning</p> <p>It's a ray, so only one way</p> <ul> <li>Easily done by checking the sign of the cross product of the vectors from \\(p\\) to the vertices of the polygon</li> </ul> Crossing Number Algorithm"},{"location":"cg/ray_tracing/#winding-number-algorithm","title":"Winding Number Algorithm","text":"<ul> <li>Winding number of a closed curve in the plane around a given point is an integer representing the total number of times that curve travels counterclockwise around the point</li> <li>If the winding number is non-zero, then the point is inside the polygon</li> </ul> Winding Number Algorithm"},{"location":"cg/surfaces_volumes/","title":"Surfaces and Volumes","text":""},{"location":"cg/surfaces_volumes/#surface-representation","title":"Surface Representation","text":"<ul> <li>Formally: Surface is a 2D manifold embedded in 3D space.</li> <li>Informally: Surface is boundary of a non-degenerate 3D solid.</li> </ul> <p>A non-degenerate solid object is one where each point can be classified as either interior or exterior.</p> <p>What is a manifold?</p> <p>An n-dimensional manifold will look like an n-dimensional Euclidean space when looked at closely. For example, if you zoom in infinitely on a hollow sphere, it will look like a 2D plane.</p>"},{"location":"cg/surfaces_volumes/#surface-classifications","title":"Surface Classifications","text":"Classification Examples Orientable/Non Orientable Torus is orientable, Klien Bottle is not Closed/Open Sphere is closed, Plane is open Manifold/Non-Manifold Sphere is manifold, Cone is non-manifold"},{"location":"cg/surfaces_volumes/#topological-classification","title":"Topological Classification","text":"<ul> <li>Topological Equivalence: Two surfaces are topologically equivalent if one can be deformed into the other without any cuts or gluing.</li> <li>Genus: Maximum Number of cuttings along non-intersecting closed curves that can be made without separating the surface.</li> </ul>"},{"location":"cg/surfaces_volumes/#operational-classification","title":"Operational Classification","text":"<ul> <li>Evaluation: The sampling of the surface geometry or other surface properties.</li> <li>Modification: A surface can be changed in terms of geometry(deformations) or topology(cuts, gluing).</li> <li>Query: Spacial queries to determine if given point is inside or outside the solid bounded by the surface, or distance of point from the surface.</li> </ul>"},{"location":"cg/surfaces_volumes/#surface-representation_1","title":"Surface Representation","text":"<ul> <li>Implicit Surfaces: Defined as the set of points satisfying an equation \\(f(x, y, z) = 0\\).</li> <li>Parametric Surfaces: \\(S(u, v) = (x(u, v), y(u, v), z(u, v))\\) where \\(S: \\mathbb{R}^2 \\rightarrow \\mathbb{R}^3\\).</li> </ul>"},{"location":"cg/surfaces_volumes/#volume-representation","title":"Volume Representation","text":""},{"location":"cg/surfaces_volumes/#uniform-grid","title":"Uniform Grid","text":"<ul> <li>Trivial 3D grid where each cell is a cube, and it stores certain data, like color, density, etc. Used in medical imaging, many GPU applications, etc.</li> </ul> <p>Construction:</p> <ul> <li>Find the bounding box of the object.</li> <li>Define grid resolution (manual or automatic).</li> <li>Choose indexing and create huge arrays in memory</li> <li>For each cell, sample desired values and store them in cell</li> <li>Huge memory overhead!</li> </ul> <p>Pros</p> <ul> <li>Trivial to implement</li> <li>Very parallelizable</li> <li>Trivial boolean operations</li> </ul> <p>Cons</p> <ul> <li>Huge memory overhead</li> <li>large 3D loops make algorithms too slow</li> </ul> Z-Order Curve / Z Indexing <p>This is a traversal method for 3D grids, where the cells are traversed in a specific order, which provides better cache coherency and locality.</p> <p> Z-Order Curve </p>"},{"location":"cg/surfaces_volumes/#octree","title":"Octree","text":"<p>Adaptive grid structure where cells are recursively subdivided until a certain criterion is met. Each non-leaf node has 8 half-sized children. Used in Volume data storage, Color quantization, Collision detection, etc.</p> Octree"},{"location":"cg/surfaces_volumes/#data-structure","title":"Data structure","text":"<ul> <li>Node<ul> <li><code>NodeType</code> type</li> <li><code>NodeRef subNodes[8]</code></li> </ul> </li> <li>NodeType<ul> <li><code>EMPTY</code> - all children are empty</li> <li><code>MIXED</code> - atleast one non-empty subcell</li> <li><code>FULL</code> - all children are full</li> </ul> </li> </ul>"},{"location":"cg/surfaces_volumes/#construction","title":"Construction","text":"<ul> <li>Top down approach:<ul> <li>Fit whole data(geometry) into one bounding cell</li> <li>If it is mixed $ \\rightarrow $ subdivide into 8 children</li> <li>Repeat recursively until there is nothing more to subdivide</li> </ul> </li> <li>Bottom up approach:<ul> <li>Create uniform grid with high resolution</li> <li>For each 8 neighbours do:<ul> <li>If all are empty, merge them</li> <li>If all are full, merge them</li> <li>Else, create mixed parent cell and continue</li> </ul> </li> </ul> </li> </ul> <p>Pros</p> <ul> <li>Memory efficient</li> <li>Fast boolean operations</li> <li>Adaptive resolution</li> </ul> <p>Cons</p> <ul> <li>Longer point localization (data search)</li> <li>Small changes in geometry can lead to large changes in tree</li> </ul>"},{"location":"cg/transformations/","title":"Geometric Transformations","text":"<p>Transformations are very fundamental in computer graphics. They are used for Object Modelling, Viewing, and Projection. </p> <p>Objects in a scene are a collection on points which have some location, orientation and size. These properties can be changed by Translations(\\(\\mathbf{T}\\)), Rotations(\\(\\mathbf{R}\\)), and Scaling (\\(\\mathbf{S}\\)).</p>"},{"location":"cg/transformations/#homogeneous-coordinates","title":"Homogeneous Coordinates","text":"<p>We can represent Rotation and Scaling as 2x2 matrices, but we cannot do so for Translation. There is non-linearity in Translation. To make Translation linear, we use Homogeneous Coordinates. This allows us to represent all 3 2D transformations as 3x3 matrices.</p> Proof that translation is non-linear <p>Let \\(\\mathbf{T}(p) = p + t\\) be the translation of point \\(p\\) by vector \\(t\\). Then,</p> \\[\\mathbf{T}(p + q) = p + q + t \\neq \\mathbf{T}(p) + \\mathbf{T}(q)\\] \\[\\mathbf{T}(ap) = ap + t \\neq a\\mathbf{T}(p)\\] <p>Hence, Translation is non-linear.</p> <p>To convert a point \\((x, y)\\) to Homogeneous Coordinates, we do the following:</p> \\[\\begin{bmatrix}x\\\\y\\end{bmatrix} \\rightarrow \\begin{bmatrix}wx\\\\wy\\\\w\\end{bmatrix}, w \\neq 0\\] <p>where \\(w\\) is a scaling factor. We can convert back to Cartesian Coordinates by dividing by \\(w\\). For linear transformations, embed the 2x2 matrix in a 3x3 matrix by adding a row and a column of 0s and a 1 in the bottom right corner.</p> \\[\\begin{bmatrix}a &amp; b\\\\c &amp; d\\end{bmatrix} \\rightarrow \\begin{bmatrix}a &amp; b &amp; 0\\\\c &amp; d &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\]"},{"location":"cg/transformations/#2d-transformations-in-homogeneous-coordinates","title":"2D Transformations in Homogeneous Coordinates","text":"Transformation Matrix Translation \\(\\begin{bmatrix}1 &amp; 0 &amp; t_x\\\\0 &amp; 1 &amp; t_y\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\) Rotation \\(\\begin{bmatrix}\\cos\\theta &amp; -\\sin\\theta &amp; 0\\\\\\sin\\theta &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\) Scaling \\(\\begin{bmatrix}s_x &amp; 0 &amp; 0\\\\0 &amp; s_y &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\) \\(\\text{Shear}_x\\) (\\(\\phi\\) is angle along axis) \\(\\begin{bmatrix}1 &amp; \\tan{\\phi} &amp; 0\\\\0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\) \\(\\text{Shear}_y\\) \\(\\begin{bmatrix}1 &amp; 0 &amp; 0\\\\ \\tan{\\phi} &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 1\\end{bmatrix}\\) Properties of Rotation Matrix <ul> <li>\\(\\mathbf{R}^\\top = \\mathbf{R}^{-1}\\)</li> <li>\\(\\det(\\mathbf{R}) = 1\\)</li> </ul> <p>Make sure these are always satisfied.</p>"},{"location":"cg/transformations/#composition-of-transformations","title":"Composition of Transformations","text":"<p>To apply multiple transformations to a point, we multiply the matrices of the transformations. The order of multiplication is important. For example, to rotate and then translate a point, we would do \\(\\mathbf{T}\\mathbf{R}p\\). Operations are evaluated from right to left.</p> <p>Order of Multiplication</p> <p>In general, Matrix Multiplication is not commutative. \\(\\mathbf{AB} \\neq \\mathbf{BA}\\).</p>"},{"location":"cg/transformations/#transformation-about-arbitrary-point","title":"Transformation about Arbitrary Point","text":"<p>To rotate a point about an arbitrary point \\((p_x, p_y)\\), we first translate the point to the origin, rotate it, and then translate it back.</p> \\[ \\mathbf{R}_p(\\phi) = \\mathbf{T}(p_x, p_y) \\hspace{10px} \\mathbf{R}(\\phi) \\hspace{10px} \\mathbf{T}(-p_x, -p_y) \\] <p>Similarly for scaling, we can perform the following:</p> \\[ \\mathbf{S}_p(s_x, s_y) = \\mathbf{T}(p_x, p_y) \\hspace{10px} \\mathbf{S}(s_x, s_y) \\hspace{10px} \\mathbf{T}(-p_x, -p_y) \\]"},{"location":"cg/transformations/#decomposition-of-transformations","title":"Decomposition of Transformations","text":"<p>Any 2D matrix can be decomposed into a product of rotation, scale, rotation. </p> <ul> <li>Eigenvalue Decomposition: \\(\\mathbf{A} = \\mathbf{R} \\hspace{10px} \\mathbf{S} \\hspace{10px} \\mathbf{R}^{\\top}\\) </li> </ul> <p>Note</p> <p>Eigenvalue Decomposition only works for symmetric matrices.</p> <p>Info</p> <ul> <li>\\(\\mathbf{R}^{\\top}\\): Rotate the object to X and Y axes.</li> <li>\\(\\mathbf{S}\\): Scale the object.</li> <li>\\(\\mathbf{R}\\): Rotate the object back to its original orientation.</li> </ul> <p>In a way it's directional scaling.</p> <ul> <li> <p>SVD Decomposition: \\(\\mathbf{A} = \\mathbf{U} \\hspace{10px} \\mathbf{S} \\hspace{10px} \\mathbf{V}^{\\top}\\)</p> </li> <li> <p>Paeth Decomposition: Applies only to rotations. Uses shear to represent non-zero rotations. Very useful in raster image rotations.</p> </li> </ul> \\[ \\begin{bmatrix} \\cos\\theta &amp; -\\sin\\theta \\\\ \\sin\\theta &amp; \\cos\\theta \\end{bmatrix} = \\begin{bmatrix} 1 &amp; \\frac{\\cos \\phi - 1}{\\sin \\phi} \\\\ 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 &amp; 0 \\\\ \\sin \\phi &amp; 1 \\end{bmatrix} \\begin{bmatrix} 1 &amp; \\frac{ \\cos \\phi - 1}{\\sin \\phi} \\\\ 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"cg/transformations/#3d-transformations","title":"3D Transformations","text":"<p>Properties which were applicable in 2D transformations are also applicable in 3D transformations. The only difference is that we have an additional axis.</p> Transformation Matrix Translation \\(\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; t_x\\\\0 &amp; 1 &amp; 0 &amp; t_y\\\\0 &amp; 0 &amp; 1 &amp; t_z\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\) Rotation about X-axis \\(\\begin{bmatrix}1 &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; \\cos\\theta &amp; -\\sin\\theta &amp; 0\\\\0 &amp; \\sin\\theta &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\) Rotation about Y-axis \\(\\begin{bmatrix}\\cos\\theta &amp; 0 &amp; \\sin\\theta &amp; 0\\\\0 &amp; 1 &amp; 0 &amp; 0\\\\-\\sin\\theta &amp; 0 &amp; \\cos\\theta &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\) Rotation about Z-axis \\(\\begin{bmatrix}\\cos\\theta &amp; -\\sin\\theta &amp; 0 &amp; 0\\\\\\sin\\theta &amp; \\cos\\theta &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; 1 &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\) Scaling \\(\\begin{bmatrix}s_x &amp; 0 &amp; 0 &amp; 0\\\\0 &amp; s_y &amp; 0 &amp; 0\\\\0 &amp; 0 &amp; s_z &amp; 0\\\\0 &amp; 0 &amp; 0 &amp; 1\\end{bmatrix}\\)"},{"location":"cg/transformations/#arbitrary-axis-rotation","title":"Arbitrary Axis Rotation","text":"<p>Given 3 mutually orthogonal unit vectors \\(\\mathbf{u} = (x_u, y_u, z_u)\\), \\(\\mathbf{v} = (x_v, y_v, z_v)\\), \\(\\mathbf{w} = (x_w, y_w, z_w)\\), \\(R_{uvw}\\) transforms the coordinate system from \\(xyz\\) to \\(uvw\\).</p> \\[ R_{uvw} = \\begin{bmatrix} x_u &amp; y_u &amp; z_u \\\\ x_v &amp; y_v &amp; z_v \\\\ x_w &amp; y_w &amp; z_w\\end{bmatrix} = \\begin{bmatrix} u \\\\ v \\\\ w \\end{bmatrix} \\] <p>To rotate around arbitrary vector \\(\\mathbf{a} = (x_a, y_a, z_a)\\)</p> <ul> <li>Form an orthonormal \\(uvw\\) coordinate system with \\(w = \\mathbf{a}\\) </li> <li>Rotate \\(uvw\\) basis to canonical basis \\(xyz\\)</li> <li>Rotate about \\(z\\) axis by \\(\\phi\\)</li> <li>Rotate back to \\(uvw\\) basis</li> </ul> \\[R_a(\\phi) = R_{uvw}^\\top \\hspace{10px} R_z(\\phi) \\hspace{10px} R_{uvw}\\]"},{"location":"cg/transformations/#constructing-a-basis-from-a-vector","title":"Constructing a basis from a vector","text":"<ul> <li>make \\(w\\) a unit vector \\(w = \\frac{a}{||a||}\\)</li> <li>Choose any vector \\(t\\) not parallel to \\(w\\), and build \\(u = \\frac{t \\times w}{||t \\times w||}\\)</li> <li>Complete the basis by \\(v = w \\times u\\)</li> </ul>"},{"location":"cg/transformations/#transforming-normals","title":"Transforming Normals","text":"<ul> <li>Normals are very common in computer graphics, so we need a way to also transform surface normals.</li> <li>They do not transform the way surfaces do </li> <li>Let the surface points be transformed by the matrix \\(\\mathbf{M}\\). Then the normal vectors are transformed by the the following</li> </ul> \\[ \\mathbf{N'} = \\mathbf{M}^{-\\top} \\mathbf{N} \\]"},{"location":"cg/viewing/","title":"Viewing and Projections","text":""},{"location":"cg/viewing/#types-of-projections","title":"Types of Projections","text":"<ul> <li>Orthographic/Parallel: projection lines are all parallel to each other (direction of projection or DOP)</li> <li>Perspective: projection lines converge at a single point (center of projection or COP)</li> </ul> Perspective vs Orthographic Projection <p>Note</p> <p>There are many types of projections, but all of them can be classified into these two categories.</p> <p>There are many more subtypes of Parallel projection than Perspective projection.</p>"},{"location":"cg/viewing/#parallel-projections","title":"Parallel Projections","text":"<p>In the given figure, DOP is the direction of projection and VPN is view plane normal. Assume object face of interest lies in principal plane.</p> Types of Parallel Projections Type Description VPN \\(\\parallel\\) a principal axis? DOP \\(\\parallel\\) VPN? Multiview Orthographic Shows a single face, exact measurements Yes Yes Axonometric Adjacent faces, none exact, uniformly foreshortened No Yes Oblique adjacent faces, one exact, others uniformly foreshortened Yes No What the hell is foreshortening? <p>Foreshortening is the visual effect or optical illusion that causes an object or distance to appear shorter than it actually is because it is angled toward the viewer.</p>"},{"location":"cg/viewing/#multiview-orthographic-projections","title":"Multiview Orthographic Projections","text":"<ul> <li>Projectors are orthogonal to the projection plane</li> <li>Projection plane is parallel to one of the principal planes</li> <li>Think of taking front view, top view, and side view of an object</li> </ul>"},{"location":"cg/viewing/#axonometric-projections","title":"Axonometric Projections","text":"Different types of Axonometric Projections Type Description   Isometric All three principal axes equal (\\(120^\\circ\\)) Dimetric Two principal axes are equal Trimetric All three principal axes are different <p>Skipping Oblique Projections for now.</p>"},{"location":"cg/viewing/#perspective-projections","title":"Perspective Projections","text":"<ul> <li>Describes the way we see the world</li> <li>Parallel lines don't remain parallel post projection (Foreshortening is not uniform)</li> <li>View Point is the point from which the object is viewed. It's an actual point</li> <li>Vanishing Points are points where parallel lines converge. They are imaginary points.</li> </ul> Perspective Projections Type Description One-point Perspective All parallel lines converge to a single point Two-point Perspective All parallel lines converge to one of two points Three-point Perspective All parallel lines converge to one of three points <p>There can be more than three vanishing points as well, and that would be an N-point perspective.</p>"},{"location":"cg/viewing/#viewing-transformations","title":"Viewing Transformations","text":"<p>Mapping 3D locations in the canonical coordinate system to coordinates in the image. Composed of:</p> <ul> <li>A camera transformation or eye transformation</li> <li>A projection transformation</li> <li>A viewport transformation or windowing transformation</li> </ul> <p>Note</p> <p>Cannonical View Volume (CVV) is a cube containing all 3D points whose coordinates are in the range \\([-1, 1]\\).</p> <p>Viewing Frustum</p> <p>The viewing frustum is the region of space in the world that is visible in the image. It is the region of space that is mapped to the CVV.</p> <p>The pipeline is as follows</p> Viewing Transformation Pipeline"},{"location":"cg/viewing/#camera-transformation","title":"Camera Transformation","text":"<p>Positioning the camera to look in a particular direction</p> <ul> <li>The eye position \\(e\\)</li> <li>The gaze direction \\(g\\)</li> <li>The view-up vector \\(t\\)</li> </ul> <p>The user specifies viewing as a tripled \\((e, g, t)\\), using which we create basis vectors \\(u, v, w\\) as follows:</p> <ul> <li>\\(w = \\frac{-g} {\\lVert g \\rVert }\\)</li> <li>\\(u = \\frac{t \\times w} {\\lVert t \\times w \\rVert }\\)</li> <li>\\(v = w \\times u\\)</li> </ul> <p>Basic idea: Convert the camera to the origin and align the camera with the \\(z\\)-axis.</p> \\[ M_{w \\rightarrow c} = \\begin{bmatrix} u &amp; v &amp; w &amp; e \\\\  0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}^{-1} = \\begin{bmatrix}     x_u &amp; x_v &amp; x_w &amp; 0 \\\\     y_u &amp; y_v &amp; y_w &amp; 0 \\\\     z_u &amp; z_v &amp; z_w &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix}  \\begin{bmatrix}     1 &amp; 0 &amp; 0 &amp; -x_e \\\\     0 &amp; 1 &amp; 0 &amp; -y_e \\\\     0 &amp; 0 &amp; 1 &amp; -z_e \\\\     0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ M_{c \\rightarrow w} = \\begin{bmatrix} u &amp; v &amp; w &amp; e \\\\  0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] Why is \\(w = -g\\)? <p>If we change the direction of \\(w\\), the direction of \\(u\\) changes, and it looks like we have flipped the camera.</p> <p> How sign of \\(w\\) affects \\(u, v\\) </p>"},{"location":"cg/viewing/#projection-transformation","title":"Projection Transformation","text":"<p>Project points from camera space to the canonical view volume.</p>"},{"location":"cg/viewing/#orthographic-projection","title":"Orthographic Projection","text":"<p>View Volume is a rectangular parallelepiped \\([l, r] \\times [b, t] \\times [n, f]\\). The steps are:</p> <ul> <li>Move the center of the view volume to the origin</li> <li>Scale the view volume to the canonical view volume</li> </ul> \\[ M_{ortho_{t}} = \\begin{bmatrix}     1 &amp; 0 &amp; 0 &amp; -\\frac{l+r}{2} \\\\     0 &amp; 1 &amp; 0 &amp; -\\frac{t+b}{2} \\\\     0 &amp; 0 &amp; 1 &amp; -\\frac{n+f}{2} \\\\ \\end{bmatrix} , \\hspace{20px} M_{ortho_{s}} = \\begin{bmatrix}     \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; 0 \\\\     0 &amp; \\frac{2}{t-b} &amp; 0 &amp; 0 \\\\     0 &amp; 0 &amp; \\frac{2}{f-n} &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] \\[ M_{orth} = M_{ortho_s} \\times M_{ortho_t} =  \\begin{bmatrix}     \\frac{2}{r-l} &amp; 0 &amp; 0 &amp; -\\frac{r+l}{r-l} \\\\     0 &amp; \\frac{2}{t-b} &amp; 0 &amp; -\\frac{t+b}{t-b} \\\\     0 &amp; 0 &amp; \\frac{2}{f-n} &amp; -\\frac{f+n}{f-n} \\\\     0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\]"},{"location":"cg/viewing/#perspective-projection","title":"Perspective Projection","text":"<p>View Volume is a frustum with the apex at the origin. Perspective projection is not affine, so we need to use homogeneous coordinates.</p> <ul> <li>\\(d\\) is the distance from the eye to the image plane</li> <li>\\(x_s = \\frac{d}{z} x\\)</li> <li>\\(y_s = \\frac{d}{z} y\\)</li> </ul> <p>The perspective projection matrix, for a frustum with \\(n\\) and \\(f\\) as near and far planes, is:</p> \\[ M_{persp} = \\begin{bmatrix}     n &amp; 0 &amp; 0 &amp; 0 \\\\     0 &amp; n &amp; 0 &amp; 0 \\\\     0 &amp; 0 &amp; n+f &amp; -fn \\\\     0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix} \\] \\[ \\begin{pmatrix}     x \\\\ y \\\\ z \\\\ 1 \\end{pmatrix}  \\rightarrow   \\begin{pmatrix}     nx \\\\ ny \\\\ (n + f)z - fn \\\\ z  \\end{pmatrix} \\rightarrow \\begin{pmatrix}     \\frac{n}{z} x \\\\ \\frac{n}{z} y \\\\ (n + f - \\frac{fn}{z}) \\\\ 1 \\end{pmatrix} \\] <p>What is going on in the 3rd row and 4th row?</p> <ul> <li>We use one in the 4th row to introduce \\(w = z\\), which we would divide by later. to get \\(\\frac{d}{z} x\\) and \\(\\frac{d}{z} y\\). </li> <li>The 3rd row is to maintain the \\(z\\) value. We need to maintain the \\(z\\) value to calculate the depth of the object. We only care about the relative ordering so, we get </li> </ul> \\[\\tilde{z}(t) = n + f - \\frac{nf}{t}\\] <p>Where \\(t\\) is the \\(z\\) value of the object in the camera space. Notice that \\(\\tilde{z}(n) = n\\) and \\(\\tilde{z}(f) = f\\).</p>"},{"location":"cg/viewing/#full-perspective-transformation","title":"Full Perspective Transformation","text":"\\[ M_{persp} = M_{orth} \\times M_{persp} \\] \\[ M_{persp} = \\begin{bmatrix}     \\frac{2n}{r-l} &amp; 0 &amp; \\frac{r+l}{r-l} &amp; 0 \\\\     0 &amp; \\frac{2n}{t-b} &amp; \\frac{t+b}{t-b} &amp; 0 \\\\     0 &amp; 0 &amp; \\frac{f+n}{f-n} &amp; -\\frac{2fn}{f-n} \\\\     0 &amp; 0 &amp; 1 &amp; 0 \\end{bmatrix} \\]"},{"location":"cg/viewing/#viewport-transformation","title":"Viewport Transformation","text":"<p>Map the canonical view volume to the screen coordinates. Image boundaries have a half-unit offset. We want to map \\([-1, 1]^2\\) to \\([-0.5, n_x - 0.5] \\times [-0.5, n_y - 0.5]\\)</p> <p>The transformation to map points in \\([x_l, x_h] \\times [y_l, y_h]\\) to \\([x_l', x_h'] \\times [y_l', y_h']\\) is called Windowing Transformation. The steps are:</p> <ul> <li>Move \\([x_l, y_l]\\) to \\([0, 0]\\)</li> <li>Scale the rectangle to the target rectangle</li> <li>Move the rectangle to \\([x_l', y_l']\\)</li> </ul> \\[ M_{win} = \\begin{bmatrix}     1 &amp; 0 &amp; x_l' \\\\     0 &amp; 1 &amp; y_l' \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix}     \\frac{x_h' - x_l'}{x_h - x_l} &amp; 0 &amp; 0 \\\\     0 &amp; \\frac{y_h' - y_l'}{y_h - y_l} &amp; 0 \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} \\begin{bmatrix}     1 &amp; 0 &amp; -x_l \\\\     0 &amp; 1 &amp; -y_l \\\\     0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>For the screen coordinates, we have \\([0, n_x] \\times [0, n_y]\\), so \\(x_l = 0, x_h = n_x, y_l = 0, y_h = n_y\\).</p> \\[ M_{vp} = \\begin{bmatrix}     \\frac{n_x}{2} &amp; 0 &amp; 0 &amp; \\frac{n_x - 1}{2} \\\\     0 &amp; \\frac{n_y}{2} &amp; 0 &amp; \\frac{n_y - 1}{2} \\\\     0 &amp; 0 &amp; 1 &amp; 0 \\\\     0 &amp; 0 &amp; 0 &amp; 1 \\end{bmatrix} \\] <p>Note</p> <p>The \\(z\\)-coordinate is preserved after the viewport transformation, as it will be used for depth testing.</p>"},{"location":"ff/financial_statements/","title":"Analysis of Financial Statements","text":"<p>Financial statements are record of financial activities of a business.</p> <ul> <li>Current Assets: Used within a year<ul> <li>Cash, Inventory, Accounts Receivable</li> </ul> </li> <li>Non-current Assets: Used for more than a year<ul> <li>Land, Building, Equipment</li> </ul> </li> <li>Current Liabilities: Due within a year<ul> <li>Accounts Payable, Short-term Loans</li> </ul> </li> <li>Non-current Liabilities: Due after a year<ul> <li>Long-term Loans, Bonds </li> </ul> </li> <li>Shareholder's Equity: Assets - Liabilities<ul> <li>Common Stock, Retained Earnings</li> </ul> </li> </ul> <p>Important</p> <p>Balance sheet should always be balanced. Assets = Liabilities + Shareholder's Equity</p> Which one was Debit and Which one was Credit? <ul> <li>Debit: Left side of the account (when you get money)</li> <li>Credit: Right side of the account (when you pay money)</li> </ul>"},{"location":"ff/financial_statements/#balance-sheet","title":"Balance Sheet","text":""},{"location":"ff/financial_statements/#example","title":"Example","text":"<ul> <li>Issues shares for 100 in cash</li> </ul> Assets   Cash 100 Total Assets 100 Liabilities   Shareholders'Equity 100 Total Liabilities 100 <ul> <li>Taking out a 4 year bank load of 50</li> </ul> Assets  Cash 150 Total Assets 150 Liabilities   Non-current Liabilities 50 Shareholders'Equity 100 Total Liabilities 150 <ul> <li>Buying a machinery for 80</li> </ul> Assets   Cash 70 Equipment 80 Total Assets 150 Liabilities Non-current Liabilities 50 Shareholders'Equity 100 Total Liabilities 150 <ul> <li>Buying Inventory for 60</li> </ul> Assets  Cash 10 Inventory 60 Equipment 80 Total Assets 150 Liabilities   Non-current Liabilities 50 Shareholders'Equity 100 Total Liabilities 150 <ul> <li>Selling Inventory for 90</li> </ul> Assets   Cash 100 Inventory 0 Equipment 80 Total Assets 180 Liabilities   Non-current Liabilities 50 Shareholders'Equity 100 Revenue 90 Cost of Sales (60) Total Liabilities 180 <ul> <li>Paying salary of 20</li> </ul> Assets   Cash 80 Inventory 0 Equipment 80 Total Assets 160 Liabilities   Non-current Liabilities 50 Shareholders'Equity 100 Revenue 90 Cost of Sales (60) Salary (20) Total Liabilities 160 <ul> <li>Paying interest of 3</li> </ul> Assets   Cash 77 Inventory 0 Equipment 80 Total Assets 157 Liabilities   Non-current Liabilities 50 Shareholders'Equity 100 Revenue 90 Cost of Sales (60) Salary (20) Interest (3) Total Liabilities 157"},{"location":"ff/financial_statements/#accounts-receivable-and-accounts-payable","title":"Accounts Receivable and Accounts Payable","text":"<ul> <li>Accounts Receivable: Money that is owed to the company</li> <li>Accounts Payable: Money that the company owes to others</li> </ul> <p>If we were to use credit to buy inventory at 60, and sell it at 90, the balance sheet would look like this:</p> Assets   Cash 47 Inventory 0 Accounts Receivable 90 Equipment 80 Total Assets 217 Liabilities   Current Liabilities 60 Non-current Liabilities 50 Shareholders'Equity 100 Revenue 90 Cost of Sales (60) Salary (20) Interest (3) Total Liabilities 217 Another Example <ul> <li>Issues shares of 300</li> <li>Bought equipment for 200</li> <li>Bought inventory for 100, 80 of this was cash, remainder is outstanding</li> <li>Sold 75% of inventory for 120, 100 has been received in cash</li> <li>Paid cash expense of 15</li> </ul> <p>What would the balance sheet look like?</p> <ul> <li>Issued shares of 300</li> </ul> Assets   Cash 300 Total Assets 300 Liabilities   Shareholders'Equity 300 Total Liabilities 300 <ul> <li>Bought equipment for 200</li> </ul> Assets   Cash 100 Equipment 200 Total Assets 300 Liabilities   Shareholders'Equity 300 Total Liabilities 300 <ul> <li>Bought inventory for 100, 80 of this was cash, remainder is outstanding</li> </ul> Assets   Cash 20 Inventory 100 Equipment 200 Total Assets 320 Liabilities   Current Liabilities 20 Shareholders'Equity 300 Total Liabilities 320 <ul> <li>Sold 75% of inventory for 120, 100 has been received in cash</li> </ul> <p>75% of 100 is 75, so 25 of inventory remains</p> Assets   Cash 120 Accounts Receivable 20 Inventory 25 Equipment 200 Total Assets 365 Liabilities   Current Liabilities 20 Shareholders'Equity 300 Revenue 120 Cost of Sales (75) Total Liabilities 365 <ul> <li>Paid cash expense of 15</li> </ul> Assets   Cash 105 Accounts Receivable 20 Inventory 25 Equipment 200 Total Assets 350 Liabilities   Current Liabilities 20 Shareholders'Equity 300 Revenue 120 Cost of Sales (75) Expense (15) Total Liabilities 350"},{"location":"ff/financial_statements/#income-statement","title":"Income Statement","text":"<p>Income statement is a record of financial activities of a business over a period of time.</p> <ul> <li>Revenue: Money earned from selling goods or services</li> <li>Direct Costs: Costs directly related to producing goods or services</li> <li>Indirect Costs: Costs not directly related to producing goods or services</li> <li>Gross Profit: Revenue - Direct Costs</li> <li>Operating Profit: Gross Profit - Indirect Costs</li> <li>Net Profit: Operating Profit - Tax and Interest</li> </ul>"},{"location":"ff/financial_statements/#some-other-terms","title":"Some other terms","text":"<ul> <li>Accrued Expenses : Expenses that have been incurred but not yet paid (office supplies of 2000 were used but will pe paid next year)</li> <li>Prepayment : Payment made in advance (1 year insurance, but paid in monthly installments)</li> <li>Depreciation : Reduction in value of an asset over time </li> </ul>"},{"location":"ff/financial_statements/#cash-flow-statement","title":"Cash Flow Statement","text":"<ul> <li>Cash from Operating Activities: Cash generated from day-to-day operations</li> <li>Cash from Investing Activities: Cash generated from buying and selling assets</li> <li>Cash from Financing Activities: Cash generated from issuing shares or taking loans</li> </ul> <p>Example</p> <p>ABC. Inc. buys a truck for $45,000 will use it in the business for 5 years, and in 5 years expects to sell it for  $15,000</p> <ul> <li>Balance Sheet - Assets : 39,000</li> <li>Income Statement - Depreciation : 6,000</li> <li>Cash Flow Statement - Investing Activities : 45,000</li> </ul>"},{"location":"ff/financial_statements/#calculating-operating-cash-flow-direct-method","title":"Calculating operating cash flow - direct method","text":"<p>Operating cash inflow - Operating cash outflow = Net operating cash flow</p> <p>This method is rarely used</p>"},{"location":"ff/financial_statements/#calculating-operating-cash-flow-indirect-method","title":"Calculating operating cash flow - indirect method","text":"Net Income A Depreciation B (Increase)/Decrease in Receivable (C)/C (Increase)/Decrease in Inventory (D)/D Increase/(Decrease) in Payable E/(E) Net Operating Cash Flow X Example <ul> <li>Cash Purchases: 250</li> <li>Cash Sales: 370</li> <li>Cash expenses: 40</li> <li>Depreciation: 55</li> </ul> Income Statement Revenue 370 Purchases (250) Expenses (40) Depreciation (55) Net Income 25 Cash flow direct Cash Sales 370 Cash Purchases (250) Cash Expenses (40) Net Operating Cash Flow 80 Cash flow indirect Net Income 25 Depreciation 55 Increase in Receivable 80 Example <ul> <li>Cash Purchases: 280</li> <li>Cash sales: 300</li> <li>Sales on Credit: 170</li> <li>Cash expenses: 50</li> <li>Receipts on receivables: 140</li> <li>Depreciation: 55</li> </ul> Income Statement Revenue 300 + 170 Purchases (280) Expenses (50) Depreciation (55) Net income 85 Cash flow direct Revenue 300 + 140 Purchases (280) Expenses (50) Change in cash 110 Cash flow indirect Net income 85 Depreciation 55 Increase in AC Receivables 140 - 170 Change in cash 110 Example <ul> <li>Cash purchases: 150</li> <li>Cash sales: 320</li> <li>Sales on credit : 310</li> <li>Purchases on credit: 180</li> <li>Receipts from receivables: 260</li> <li>Payments to payables: 140</li> <li>Cash expenses: 70</li> <li>Depreciation: 55</li> </ul> Income Statement Sales 320 + 310 Purchases (150 + 180) Expenses (70) Depreciation (55) Net income 175 Cash flow direct Inflow 320 + 260 Purchases (150 + 140) Expenses (70) Change in cash 220 <p>| Cash flow indirect | | | Net income | 175 | | Depreciation | 55 | | Account Receivables | (310 - 260 = 50) |  | Account Payables | 180 - 140 = 40 | | Change in cash | 220 |</p>"},{"location":"ff/financial_statements/#deriving-complete-cash-flow-statement","title":"Deriving complete cash flow statement","text":"<p>It's possible to derive cash flow statements using </p> <ul> <li>Last year's balance sheet</li> <li>This year's balance sheet</li> <li>This year's income statement</li> </ul>"},{"location":"ff/financial_statements/#stage-one-compare-the-balance-sheets","title":"Stage one - Compare the balance sheets","text":"<ul> <li>If assets have increased =&gt; cash outflow</li> <li>If liabilities have increased =&gt; cash inflow. </li> </ul>"},{"location":"ff/financial_statements/#stage-two-classifying-the-cash-flow","title":"Stage two - classifying the cash flow","text":"<p>Classify each of the cash flow statements into the following :-</p> <ul> <li>Operating cash flows</li> <li>Investing cash flows</li> <li>Financial cash flows</li> </ul> <p>The cash flow we have looked at so far is operating cash flows</p> <p>Difference in PP&amp;E is occurred due to</p> <ul> <li>Depreciation lowering PP&amp;E</li> <li>Net capital expenditure (a.k.a. CAPEX) increase PPE</li> </ul> \\[ \\text{Opening PP&amp;E} + \\text{Net CAPEX} - \\text{Depreciation} = \\text{Closing PP&amp;E} \\] <p>Difference in retained earnings is due to</p> <ul> <li>Net income (added)</li> <li>Dividends (subtracted)</li> </ul>"},{"location":"ff/financial_statements/#some-important-quantities","title":"Some Important Quantities","text":"Quantity Formula Gross Profit Revenue - Cost of Sales Operating Profit Gross Profit - Operating Expenses Net Profit Operating Profit - Tax Operating Cash Flow Net Income + Depreciation Net Cash Flow Operating Cash Flow + Investing Cash Flow + Financing Cash Flow Free Cash Flow \\(EBIT(1 - Tax) + \\text{Depreciation} - \\text{CAPEX} -  \\Delta \\text{Net Working Capital}\\) Net working capital Current Assets - (Current Liabilities - Notes Payable)"},{"location":"ff/ratio_analysis/","title":"What is Financial Analysis?","text":"<p>Financial analysis is the process of evaluating businesses, projects, budgets, and other finance-related transactions to determine their performance and suitability. Typically, financial analysis is used to analyze whether an entity is stable, solvent, liquid, or profitable enough to warrant a monetary investment. </p>"},{"location":"ff/ratio_analysis/#types-of-financial-analysis","title":"Types of Financial Analysis","text":""},{"location":"ff/ratio_analysis/#vertical-analysis","title":"Vertical Analysis","text":"<p>Involves looking at various components of </p> <ul> <li>The income statement and dividing them by the total revenue to get a percentage</li> <li>The balance sheet and dividing them by the total assets to get a percentage</li> </ul> <p>These numbers should be compared to the industry average to see how well the company is doing. Also called common-size analysis.</p> Example <p>If the company's income statements looks as following:-</p> Total Revenue 100 Cost of Revenue 60 Gross Profit 40 Operating Expenses 10 Operating Income 30 Taxes 10 Net Income 20 <p>Then vertical analysis would look like:-</p> Gross Profit Margin 40% Operating Income Margin 30% Net Income Margin 20%"},{"location":"ff/ratio_analysis/#horizontal-analysis","title":"Horizontal Analysis","text":"<p>Involves comparing financial data over a number of years to identify trends. Helps identifying if the company is growing or shrinking. Also called trend analysis. Typically done over minimum of 3 years.</p> Example Income Statement 2019 2020 2021 Total Revenue 100 120 150 Cost of Revenue 60 70 80 Gross Profit 40 50 70 Operating Expenses 10 15 20 Operating Income 30 35 50 Taxes 10 12 15 Net Income 20 23 35 <p>Then horizontal analysis would look like:-</p> Ratio 2019 2020 2021 Gross Profit Margin 40% 41.67% 46.67% Operating Income Margin 30% 29.17% 33.33% Net Income Margin 20% 19.17% 23.33%"},{"location":"ff/ratio_analysis/#ratio-analysis","title":"Ratio Analysis","text":"<p>Quantitative measures that are used to evaluate the financial performance of a company. They should be comparable with competitor's ratios, can be observed over time to detect trends, and can be used to benchmark management performance.</p>"},{"location":"ff/ratio_analysis/#type-of-ratios","title":"Type of Ratios","text":""},{"location":"ff/ratio_analysis/#profitability-ratios","title":"Profitability Ratios","text":"<p>They answer the question: Is the firm making money?</p> Ratio Formula Interpretation Gross Profit Margin \\(\\Large\\frac{\\text{Gross Profit or EBDIT}}{\\text{Total Revenue}}\\) Measures the percentage of revenue that exceeds the cost of goods sold. Operating Profit Margin \\(\\Large\\frac{\\text{Operating Profit or EBIT }}{\\text{Total Revenue}}\\) Measures the percentage of revenue that exceeds the cost of goods sold and operating expenses. Net Profit Margin \\(\\Large\\frac{\\text{Net Income}}{\\text{Total Revenue}}\\) Measures the percentage of revenue that exceeds the cost of goods sold, operating expenses, taxes, and interest. Return on Assets(ROA) \\(\\Large\\frac{\\text{Net Income}}{\\text{Total Assets}}\\) Measures the company's ability to generate profit from its assets. Return on Equity(ROE) \\(\\Large\\frac{\\text{Net Income}}{\\text{Total Equity}}\\) Measures the company's ability to generate profit from its equity."},{"location":"ff/ratio_analysis/#liquidity-ratios","title":"Liquidity Ratios","text":"<p>They answer the question: Will the firm be able to pay off debt as they come and remain a viable business? They show the relationship of a firm\u2019s cash and other current assets to its current liabilities.</p> Ratio Formula Interpretation Current Ratio \\(\\Large\\frac{\\text{Current Assets}}{\\text{Current Liabilities}}\\) Measures the company's ability to pay off its short-term liabilities with its short-term assets. Quick Ratio \\(\\Large\\frac{\\text{Current Assets - Inventory}}{\\text{Current Liabilities}}\\) Measures the company's ability to pay off its short-term liabilities without relying on the sale of inventory. <p>Note</p> <p>Net Working Capital = Current Assets - Current Liabilities</p>"},{"location":"ff/ratio_analysis/#asset-management-ratios","title":"Asset Management Ratios","text":"<p>Measures how effectively the firm is managing it's assets. They show how efficiently the firm is using its assets to generate sales. It answers : Does the amount of each asset seem reasonable, too high, or too low?</p> Ratio Formula Interpretation Inventory Turnover \\(\\Large\\frac{\\text{Sales}}{\\text{Inventories}}\\) Measures how many times a company's inventory is sold and replaced over a period. Accounts Receivable Turnover \\(\\Large\\frac{\\text{Accounts Receivable}}{\\text{Average Sales Per Day}}\\) Measures the average number of days it takes for a company to collect payment after a sale has been made. Account Payable Turnover \\(\\Large\\frac{\\text{Cost of Goods Sold}}{\\text{Accounts Payable}}\\) Measures how many times a company pays off its accounts payable over a period. Fixed Asset Turnover \\(\\Large\\frac{\\text{Sales}}{\\text{Net Fixed Assets}}\\) Measures how effectively a company is using its fixed assets to generate revenue. Total Asset Turnover \\(\\Large\\frac{\\text{Sales}}{\\text{Total Assets}}\\) Measures how effectively a company is using its assets to generate revenue."},{"location":"ff/ratio_analysis/#debt-management-ratios","title":"Debt Management Ratios","text":"<p>Measures the company's ability to meet long-term obligations. It answers: Does the firm have the right mix of debt and equity? Does the firm have the ability to meet its long-term obligations?</p> Ratio Formula Interpretation Total Debt Ratio \\(\\Large\\frac{\\text{Total Debt}}{\\text{Total Assets}}\\) Measures the proportion of a company's assets that are financed by debt. Debt to Equity Ratio \\(\\Large\\frac{\\text{Total Debt}}{\\text{Total Equity}}\\) Measures the proportion of a company's assets that are financed by debt relative to the proportion that is financed by equity. Interest Coverage Ratio \\(\\Large\\frac{\\text{EBIT}}{\\text{Interest Expense}}\\) Measures a company's ability to meet its interest payments on its outstanding debt. Cash Coverage Ratio \\(\\Large\\frac{\\text{EBIT + Depreciation}}{\\text{Interest Expense}}\\) Measures a company's ability to meet its interest payments on its outstanding debt from its operating cash flows."},{"location":"ff/ratio_analysis/#market-value-ratios","title":"Market Value Ratios","text":"<p>Measures the company's market value. It answers: Is the company's stock overvalued or undervalued?</p> Ratio Formula Interpretation Market to Book Ratio \\(\\Large\\frac{\\text{Market Value Per Share}}{\\text{Book Value Per Share}}\\) Measures the market value of a company's equity relative to the book value of its equity. Book value per share \\(\\Large\\frac{\\text{Common Stock + retained earnings}}{\\text{Number of Shares Outstanding}}\\) Measures the value of a company's equity on a per-share basis. P/E Ratio \\(\\Large\\frac{\\text{Market Price Per Share}}{\\text{Earnings Per Share}}\\) Measures the market value of a company's equity relative to its earnings. EPS \\(\\Large\\frac{\\text{Net Income}}{\\text{Number of Shares Outstanding}}\\) Measures the amount of profit that a company has generated on a per-share basis."},{"location":"ff/ratio_analysis/#some-other-terms","title":"Some other terms","text":"<ul> <li>EBDIT: Earnings Before Depreciation, Interest, and Taxes</li> <li>EBIT: Earnings Before Interest and Taxes</li> <li>Depreciation: The decrease in value of an asset over time</li> <li>Amortization: The paying off of debt with a fixed repayment schedule in regular installments over a period of time</li> </ul>"},{"location":"ff/time_value_money/","title":"Time Value of Money","text":"<p>The main idea is that a dollar today is worth more than a dollar tomorrow. This is because you can invest that dollar today and have more than a dollar tomorrow. This is the concept of the time value of money. This has the following affects</p> <ul> <li>Spending - You can buy more with 1000 Rs today than 1000 Rs a year from now.</li> <li>Investing - You can invest 1000 Rs today and have more than 1000 Rs a year from now.</li> <li>Borrowing - You borrow money today and pay back more than you borrowed.</li> </ul> <p>Reasons for the time value of money are:</p> <ul> <li>Inflation - The value of money decreases over time.</li> <li>Uncertainty - Money today is more certain than money tomorrow.</li> </ul>"},{"location":"ff/time_value_money/#compounding","title":"Compounding","text":"\\[FV = PV(1 + i)^{n * t}\\] <p>Where:</p> <ul> <li>\\(FV\\) = Future Value</li> <li>\\(PV\\) = Present Value (Principal): The larger the principal, the greater the returns.</li> <li>\\(i\\) = Interest Rate: The higher the interest rate, the greater the returns.</li> <li>\\(n\\) = Number of compounding periods per year: The more compounding periods, the greater the returns.</li> <li>\\(t\\) = Number of years: The longer the time, the greater the returns.</li> </ul>"},{"location":"ff/time_value_money/#continuously-compounded-interest","title":"Continuously Compounded Interest","text":"\\[FV = PV  e^{i * t}\\]"},{"location":"ff/time_value_money/#interest-factor","title":"Interest Factor","text":"\\[FVIF = (1 + i)^t\\] \\[PVIF = \\frac{1}{(1 + i)^t}\\] <p>Note</p> <ul> <li>Rule of 72: To find out how long it takes to double your money, divide 72 by the interest rate.</li> </ul> Question <p>1, How much amount will one have in 30 hears if one invests Rs. 10,000 @ 10% p.a.</p> <ul> <li>Simple interest: \\(FV = 10000 * (1 + 0.1 * 30) = 40000\\)</li> <li>Compounded annually: \\(FV = 10000 * (1 + 0.1)^{30} = 174494.02\\)</li> <li>Compounded Continuously: \\(FV = 10000 * e^{0.1 * 30} = 200855\\)</li> </ul>"},{"location":"ff/time_value_money/#timeline-of-cash-flows","title":"Timeline of Cash Flows","text":"<ul> <li>1000 Rs Lumpsum in 2 years     <pre><code>timeline\n    0   :   \n    1   :  \n    2   : 1000</code></pre></li> <li>3-year Rs 100 ordinary annuity     <pre><code>timeline\n    0   : 100\n    1   : 100\n    2   : 100\n    3   : 100</code></pre></li> <li>Uneven cash flow stream     <pre><code>timeline\n    0   : -50\n    1   : 100\n    2   : 75\n    3   : 50   </code></pre></li> </ul> What is the future value of an initial Rs. 100 after 3 years if the interest rate is 10%? <p>Finding FV of cash flow is called compounding</p> <ul> <li>After 1 year: \\(FV = 100 * (1 + 0.1) = 110\\)</li> <li>After 2 years: \\(FV = 110 * (1 + 0.1) = 121\\)</li> <li>After 3 years: \\(FV = 121 * (1 + 0.1) = 133.1\\)</li> </ul> Present Value of Rs. 100 due in 3 years at 10%? <p>Finding PV of cash flow is called discounting</p> <ul> <li>After 1 year: \\(PV = \\frac{100}{1 + 0.1} = 90.91\\)</li> <li>After 2 years: \\(PV = \\frac{100}{(1 + 0.1)^2} = 82.64\\)</li> <li>After 3 years: \\(PV = \\frac{100}{(1 + 0.1)^3} = 75.13\\)</li> </ul> 5% compounded semi-annually, or 10% compounded annually, which is better? <ul> <li>5% semi-annually: \\(FV = 100 * (1 + 0.05)^{2 * 3} = 134.01\\)</li> <li>10% annually: \\(FV = 100 * (1 + 0.1)^3 = 133.1\\)</li> </ul> <p>5% semi-annually is better.</p>"},{"location":"ff/time_value_money/#annuities","title":"Annuities","text":"<p>Annuities are a series of equal payments made at regular intervals. </p>"},{"location":"ff/time_value_money/#future-value-of-annuity","title":"Future Value of Annuity","text":"\\[FVIFA = A + A(1 + r) + A(1 + r)^2 + \\ldots + A(1 + r)^{n - 1} = A \\frac{(1 + r)^n - 1}{r}\\] <p>FVIFA - Future Value Interest Factor of Annuity</p> Future Value of $1000 invested at 5% for 5 years? <p>\\(FVIFA = 1000 \\frac{(1 + 0.05)^5 - 1}{0.05} = 1276.28\\)</p>"},{"location":"ff/time_value_money/#present-value-of-annuity","title":"Present Value of Annuity","text":"\\[PVIFA = \\frac{C}{(1 + r)} + \\frac{C}{(1 + r)^2} + \\ldots + \\frac{C}{(1 + r)^n} = C \\frac{1 - (1 + r)^{-n}}{r}\\] <p>There are two types of annuities:</p> <ul> <li>Ordinary Annuity: Payments are made at the end of the period.</li> <li>Annuity Due: Payments are made at the beginning of the period.</li> </ul> \\[PVIFA_{\\text{Ordinary}} = \\frac{C}{(1 + r)} + \\frac{C}{(1 + r)^2} + \\ldots + \\frac{C}{(1 + r)^n} = C \\frac{1 - (1 + r)^{-n}}{r}\\] \\[PVIFA_{\\text{Due}} = C + \\frac{C}{(1 + r)} + \\ldots + \\frac{C}{(1 + r)^{n - 1}} = C \\frac{1 - (1 + r)^{-n}}{r} (1 + r)\\]"},{"location":"ff/time_value_money/#perpetuities","title":"Perpetuities","text":"<p>Perpetuities are annuities that continue indefinitely.</p> \\[PV= \\frac{C}{r}\\]"},{"location":"ff/time_value_money/#growing-perpetuities","title":"Growing Perpetuities","text":"<p>Perpetuities that grow at a constant rate, say \\(g\\).</p> \\[PV = \\frac{C}{r - g}\\] <p>For a growing fixed maturity annuity:</p> \\[PV = \\frac{C}{1+r} + \\frac{C(1+g)}{(1+r)^2} + \\ldots + \\frac{C(1+g)^{n-1}}{(1+r)^n} = \\frac{C}{r-g}\\left(1-\\frac{(1+g)^n}{(1+r)^n}\\right)\\]"},{"location":"ff/time_value_money/#loan-amortization","title":"Loan Amortization","text":"<p>Loan amortization is the process of paying off a loan in installments. Let's construct an amortization schedule for a loan of Rs. 1000 at 10% p.a. with 3 equal payments.</p> <ol> <li> <p>Find the required annual amount</p> <ul> <li> \\[ 1000 = A * PVIFA_{\\text{Ordinary}} = A \\frac{1 - (1 + 0.1)^{-3}}{0.1} = A * 2.4869\\] </li> </ul> \\[ A = 1000 / 2.4869 = 402.11\\] <p>Note</p> <p>Remember that \\(FV = 0\\) as the reason for amortization is to pay off the loan.</p> </li> <li> <p>Find interest paid in first year</p> <ul> <li>\\(I_1 = 1000 * 0.1 = 100\\)</li> </ul> </li> <li>Find principal repaid in first year<ul> <li>\\(P_1 = A - I_1 = 402.11 - 100 = 302.11\\)</li> </ul> </li> <li>Find outstanding balance after first year<ul> <li>\\(B_1 = 1000 - P_1 = 1000 - 302.11 = 697.89\\)</li> </ul> </li> </ol> Year Beginning Balance Payment Interest Principal Ending Balance 1 1000 402.11 100 302.11 697.89 2 697.89 402.11 69.79 332.32 366 3 366 402.11 36.6 365.51 0 <ul> <li>Total interest paid = 100 + 69.79 + 36.6 = 206.39</li> <li>Total payment = 402.11 * 3 = 1206.33</li> </ul>"}]}